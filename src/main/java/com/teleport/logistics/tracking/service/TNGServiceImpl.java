package com.teleport.logistics.tracking.service;

import com.teleport.logistics.tracking.dto.TrackingNumberReq;
import com.teleport.logistics.tracking.dto.TrackingNumberRes;
import com.teleport.logistics.tracking.exception.ErrorCode;
import com.teleport.logistics.tracking.exception.ErrorMessage;
import com.teleport.logistics.tracking.exception.TNGCustomException;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.time.Instant;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.UUID;
import java.util.concurrent.ThreadLocalRandom;
import java.util.stream.Collectors;

/**
 * The below class generates unique tracking number
 * 1. The tracking number is generated by concatenating the timestamp, customer ID, and a random number,
 * followed by character shuffling to enhance uniqueness.
 */
@Service
@Slf4j
public class TNGServiceImpl implements TNGService {
    private static final Integer BASE_36 = 36;
    private final Integer RAND_NUM;

    /**
     * Initializes a unique random number for this application instance.
     * <p>
     * A random number between 0 and 99 is generated during construction and assigned to this instance.
     */
    public TNGServiceImpl() {
        RAND_NUM = ThreadLocalRandom.current().nextInt(0, 100);
    }

    /**
     * @param trackingNumber
     * @return tracking number max of 16 characters length
     */
    private static String getTrackingNumber(String trackingNumber) {
        return trackingNumber.length() > 16 ? trackingNumber.substring(0, 16) : trackingNumber;
    }

    @Override
    public TrackingNumberRes generateTrackingNumber(TrackingNumberReq trackingNumberReq) {
        try {
            long timeStamp = System.currentTimeMillis();
            String timeStampBase36 = getFixedLengthString(Long.toString(timeStamp, BASE_36).toUpperCase(), 8);
            String customerIdBase36 = getFixedLengthString(getShortHash(trackingNumberReq.getCustomer_id()), 6);
            String randomNumBase36 = getFixedLengthString(Integer.toString(RAND_NUM, BASE_36).toUpperCase(), 2);
            String concatenatedValue = concatFields(timeStampBase36, randomNumBase36, customerIdBase36);
            log.debug("timeStampBase36 : {}\ncustomerIdBase36 : {}\nrandomNumBase36 :{}\ntrackingNumber : {}", timeStampBase36,
                    customerIdBase36, randomNumBase36, concatenatedValue);
            String trackingNumber = getTrackingNumber(concatenatedValue);
            log.info("Tracking number generated successfully : " + trackingNumber);
            return TrackingNumberRes.builder()
                    .tracking_number(trackingNumber)
                    .created_at(format(timeStamp, trackingNumberReq.getCreated_at().getZone()))
                    .build();
        } catch (Exception ex) {
            log.error("Tracking number generation error : {} ", ex.getMessage());
            throw new TNGCustomException(new ErrorMessage(ErrorCode.TRACKING_NUM_GENERATION_ERROR));
        }
    }

    private String concatFields(String timeStampBase36, String nodeIdBase36, String customerIdBase36) {
        return shuffleCharacters(customerIdBase36 + nodeIdBase36 + timeStampBase36);
    }

    private String getFixedLengthString(String input, int length) {
        if (input == null) {
            input = "";
        }
        if (input.length() >= length) {
            return input.substring(0, length);
        }
        return String.format("%" + length + "s", input).replace(' ', '0');
    }

    private String format(long timeStamp, ZoneId zoneId) {
        Instant instant = Instant.ofEpochMilli(timeStamp);
        ZonedDateTime zonedDateTime = instant.atZone(zoneId);
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ss.SSSSSSSXXX");
        return zonedDateTime.format(formatter);
    }

    /**
     * @param customerId
     * @return short hashed value of customer id with max of 6 characters length
     */
    private String getShortHash(UUID customerId) {
        try {
            MessageDigest digest = MessageDigest.getInstance("SHA-256");
            byte[] hash = digest.digest(customerId.toString().getBytes(StandardCharsets.UTF_8));
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < 3; i++) {
                sb.append(Integer.toString(Byte.toUnsignedInt(hash[i]), BASE_36).toUpperCase());
            }
            return sb.toString();
        } catch (Exception e) {
            log.error("Failed to hash customer id in getShortHash() : {}", e.getMessage());
            throw new TNGCustomException(new ErrorMessage(ErrorCode.UNKNOWN_ERROR, "Failed to hash customer ID"));
        }
    }

    /**
     * @param data
     * @return characters will be shuffled
     */
    private String shuffleCharacters(String data) {
        List<Character> chars = data.chars()
                .mapToObj(c -> (char) c)
                .collect(Collectors.toCollection(ArrayList::new));
        Collections.shuffle(chars, ThreadLocalRandom.current());
        return chars.stream().map(String::valueOf).collect(Collectors.joining());
    }
}
